"use strict";(self.webpackChunkbutlr_integrations=self.webpackChunkbutlr_integrations||[]).push([[456],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),g=l(n),m=o,p=g["".concat(c,".").concat(m)]||g[m]||h[m]||r;return n?a.createElement(p,i(i({ref:t},d),{},{components:n})):a.createElement(p,i({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=g;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},5534:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>h,default:()=>u,frontMatter:()=>d,metadata:()=>g,toc:()=>p});var a=n(7462),o=n(7294),r=n(3905);const i={data:[{time:"2021-06-22 22:35:10.655000+00:00",detections_local:[[0,0]],device_id:"00-17-0d-00-00-70-54-8a",room_tag:"office"},{time:"2021-06-22 22:35:10.655000+00:00",detections_local:[[.2,.5]],device_id:"00-17-0d-00-00-70-54-8a",room_tag:"office"},{time:"2021-06-22 22:35:10.655000+00:00",detections_local:[[.2,.1]],device_id:"00-17-0d-00-00-70-54-8a",room_tag:"office"},{time:"2021-06-22 22:35:10.655000+00:00",detections_local:[[.5,.3],[.1,.9],[.2,.5]],device_id:"00-17-0d-00-00-70-54-8a",room_tag:"office"}]};function s(e,t,n,a,o){var r=Math.cos(o),i=Math.sin(o);return[r*(n-e)+i*(a-t)+e,r*(a-t)-i*(n-e)+t]}const c=e=>{const t=(0,o.useRef)(null);let n=[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]];const r=(e,t,n)=>{e.clearRect(0,0,e.canvas.width,e.canvas.height),e.fillStyle="#000000",e.beginPath();const a=e.canvas.height/t.length,o=e.canvas.width/t.length;e.globalAlpha=.01,e.fillStyle="red",e.fillRect(0,0,e.canvas.width,e.canvas.height);for(var r=0;r<t.length;r++)for(var i=0;i<t[r].length;i++)e.beginPath(),e.globalAlpha=.95*t[r][i]/n,e.fillStyle="red",e.fillRect(r*o,i*a,o,a)},c=2.76,l=[0,0,0],d=[2.5,2.5],h=Math.tan(.5236)*c*2;let g={X:h/2,Y:h/2};return(0,o.useEffect)((()=>{const e=t.current.getContext("2d");i.data.length;let a=5,o=5,c=0;(()=>{for(var t=0;t<i.data.length;t++)i.data[t].detections_local.forEach((function(e,t){const r=e[0]*h,i=e[1]*h,m=s(g.X,g.Y,r,i,l[2]),p=m[0]+d[0]-g.X,f=m[1]+d[1]-g.Y,u=Math.floor(p/a*n.length),v=Math.floor(f/o*n.length);n[u][v]+=1,n[u][v]>c&&(c=n[u][v])}));r(e,n,c)})()}),[r]),o.createElement("canvas",(0,a.Z)({ref:t},e))},l=e=>{const t=(0,o.useRef)(null);let n=[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]];const r=(e,t,n)=>{e.clearRect(0,0,e.canvas.width,e.canvas.height),e.fillStyle="#000000",e.beginPath();const a=e.canvas.height/t.length,o=e.canvas.width/t.length;e.globalAlpha=.01,e.fillStyle="red",e.fillRect(0,0,e.canvas.width,e.canvas.height);for(var r=0;r<t.length;r++)for(var i=0;i<t[r].length;i++)e.beginPath(),e.globalAlpha=.95*t[r][i]/n,e.fillStyle="red",e.fillRect(r*o,i*a,o,a)},c=2.76,l=[0,0,0],d=[2.5,2.5],h=Math.tan(.5236)*c*2,g=h/2;return(0,o.useEffect)((()=>{const e=t.current.getContext("2d");let a,o=0,c=i.data.length,m=5,p=5,f=0,u=0;const v=()=>{const t=(new Date).getTime();t-f<500||(f=t,o>=c&&(o=0,u=0,n=[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]]),i.data[o].detections_local.forEach((function(e,t){const a=e[0]*h,o=e[1]*h,r=s(g,g,a,o,l[2]),i=r[0]+d[0]-g,c=r[1]+d[1]-g,f=Math.floor(i/m*n.length),v=Math.floor(c/p*n.length);n[f][v]+=1,n[f][v]>u&&(u=n[f][v])})),o++,r(e,n,u)),a=window.requestAnimationFrame(v)};return v(),()=>{window.cancelAnimationFrame(a)}}),[r]),o.createElement("canvas",(0,a.Z)({ref:t},e))},d={sidebar_position:1},h="Creating a custom heatmap",g={unversionedId:"tutorials/Heatmap",id:"tutorials/Heatmap",title:"Creating a custom heatmap",description:"Animated Heatmap",source:"@site/docs/tutorials/Heatmap.mdx",sourceDirName:"tutorials",slug:"/tutorials/Heatmap",permalink:"/docs/tutorials/Heatmap",draft:!1,editUrl:"https://github.com/butlrtechnologies/butlrtechnologies.github.io/tree/main/docs/tutorials/Heatmap.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"GraphQL - Get Sensors",permalink:"/docs/tutorials/GraphQLGetSensors"},next:{title:"Current Occupancy - Presence Sensors",permalink:"/docs/tutorials/OccupancyPresence"}},m={},p=[{value:"Animated Heatmap",id:"animated-heatmap",level:2},{value:"Historical Heatmap",id:"historical-heatmap",level:2},{value:"Get Sensor Information",id:"get-sensor-information",level:2},{value:"Activity From StreamAPI to Heatmap",id:"activity-from-streamapi-to-heatmap",level:2},{value:"StreamAPI Data Parsing",id:"streamapi-data-parsing",level:3},{value:"Transform Stream API local to Sensor Coordinates",id:"transform-stream-api-local-to-sensor-coordinates",level:2},{value:"Transform to world coordinates",id:"transform-to-world-coordinates",level:2},{value:"Project into Heatgrid",id:"project-into-heatgrid",level:2},{value:"Rendering the Heatgrid",id:"rendering-the-heatgrid",level:2},{value:"All together",id:"all-together",level:2}],f={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"creating-a-custom-heatmap"},"Creating a custom heatmap"),(0,r.kt)("h2",{id:"animated-heatmap"},"Animated Heatmap"),(0,r.kt)(l,{loc:[0,0],rot:0,mdxType:"AnimatedCanvas"}),(0,r.kt)("h2",{id:"historical-heatmap"},"Historical Heatmap"),(0,r.kt)(c,{loc:[0,0],rot:0,mdxType:"Canvas"}),(0,r.kt)("h2",{id:"get-sensor-information"},"Get Sensor Information"),(0,r.kt)("p",null,"Use the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.butlr.io/#operation/get-sensors-id"},"Sensor Details API")," to get coordinates, height, and orientation."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Note Orientation is stored in Yaw, pitch, roll ","[0.0., 0.0, 0.0]"," (unit: degrees)")),(0,r.kt)("h2",{id:"activity-from-streamapi-to-heatmap"},"Activity From StreamAPI to Heatmap"),(0,r.kt)("p",null,"Use the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.butlr.dev/#tag/Streams"},"REST API")," to get the time and ",(0,r.kt)("inlineCode",{parentName:"p"},"detections_local")," data."),(0,r.kt)("h3",{id:"streamapi-data-parsing"},"StreamAPI Data Parsing"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'{\n    "data": [\n        {\n            "time": "2021-06-22 22:35:10.655000+00:00",\n            "detections_local": [\n                [\n                    0.5,\n                    0.5\n                ]\n            ],\n        "device_id": "00-17-0d-00-00-70-54-8a",\n        "room_tag": "office"\n        },\n        {\n            "time": "2021-06-22 22:35:10.655000+00:00",\n            "detections_local": [\n                [\n                    0.5,\n                    0.5\n                ]\n            ],\n        "device_id": "00-17-0d-00-00-70-54-8a",\n        "room_tag": "office"\n        },\n    ]\n}\n')),(0,r.kt)("h2",{id:"transform-stream-api-local-to-sensor-coordinates"},"Transform Stream API local to Sensor Coordinates"),(0,r.kt)("p",null,"Since we get a historical location, we will first change the local coordinate into the sensor coordinate. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// Get the Sensor information from the Sensor API\nconst sensor = {height: 2.76, orientation: [0, 0, 0], coordinates: [2.5, 2.5]} // Example Sensor\n// Field of view is currently constant and is 60 degrees\nconst fov = 1.0472 // rad := 60 degrees\n// Get the projected sensor size, which is a square projected to the ground based on the height, therefore we use the tangent of half the fov * height(adjacent) * 2\nconst sensorSize =  Math.tan(fov/2)*sensor.height*2 // this gives us the sensor projected coverage in meters\n// Then half the sensor size is the center of the sensor\nconst sensorCenter = sensorSize/2\n\n// Get the detections_local from the StreamAPI and iterate through them to get the sensor coordinates\nfor (var i = 0; i < SampleSensorData.data.length; i++) {\n    SampleSensorData.data[i].detections_local.forEach(function(detection, index) {\n        // Scale the detection to the sensor size, [0,0] is top left [x,y], so multiple the 0-1 detection value by the sensor size\n        const xLocal = item[0] * sensorSize\n        const yLocal = item[1] * sensorSize\n        //...\n    }\n}\n")),(0,r.kt)("h2",{id:"transform-to-world-coordinates"},"Transform to world coordinates"),(0,r.kt)("p",null,"For this we will rotate the local coordinates by the orientation of the sensor, and translate by adding the sensor coordinates."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// This function rotates around the center cx, cy, by the angle theta\nconst rotate = (cx, cy, x, y, degrees) => {\n    var radians = degres * Math.PI/180,\n        cos = Math.cos(radians),\n        sin = Math.sin(radians),\n        nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,\n        ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;\n    return [nx, ny];\n}\n\n// Get the detections_local from the StreamAPI and iterate through them to get the sensor coordinates\nfor (var i = 0; i < SampleSensorData.data.length; i++) {\n    SampleSensorData.data[i].detections_local.forEach(function(detection, index) {\n        // Scale the detection to the sensor size, [0,0] is top left [x,y], so multiple the 0-1 detection value by the sensor size\n        const xLocal = item[0] * sensorSize\n        const yLocal = item[1] * sensorSize\n        // Then rotate the detection to the local frame, orientation is in terms of the center, so we need to rotate around the center\n        // Note we only rotate around the z axis (roll)\n        const rotated = rotate(sensorCenter.X, sensorCenter.Y, xLocal, yLocal, sensor.orientation[2])\n        // Next we translate to the global frame, note coordinates are to the sensor center, so we need to subtract the sensor center\n        const xGlobal = rotated[0] + sensor.coordinates[0] - sensorCenter.X\n        const yGlobal = rotated[1] + sensor.coordinates[1] - sensorCenter.Y\n        //...\n    }\n}\n")),(0,r.kt)("h2",{id:"project-into-heatgrid"},"Project into Heatgrid"),(0,r.kt)("p",null,"Here we take the world coordinates and project them into a grid. We will use a 2D array to represent the grid, and we will use the number of detections to represent the intensity of the heatmap. We will also keep track of the maximum intensity to normalize the heatmap.\nYou can use the Spaces API to get the size of the space to accurately project the heatmap."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let gridSize = {width: 5, height: 5} // meters\nlet grid = [[0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0]]\n\n//....\n// Now we place this into the grid, we need to convert the meters to the grid size\nconst xGrid = Math.floor((xGlobal/gridSize.width) * grid.length)\nconst yGrid = Math.floor((yGlobal/gridSize.height) * grid.length)\ngrid[xGrid][yGrid] += 1\n")),(0,r.kt)("h2",{id:"rendering-the-heatgrid"},"Rendering the Heatgrid"),(0,r.kt)("p",null,"Use the grid, and the maximum intensity to render the heatmap. You can use a shader to choose different colors based on the intensity. In this case I chose to change the opacity (alpha) to display the heatmap."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const draw = (ctx, grid, max_int) => {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n    ctx.fillStyle = \'#000000\'\n    ctx.beginPath()\n    const height = ctx.canvas.height/grid.length\n    const width = ctx.canvas.width/grid.length\n    ctx.globalAlpha = 0.01;\n    ctx.fillStyle = "red";\n    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n    for (var i = 0; i < grid.length; i++) { \n        for (var j = 0; j < grid[i].length; j++) { \n            ctx.beginPath()\n            ctx.globalAlpha = 0.95 * (grid[i][j])/max_int;\n            ctx.fillStyle = "red";\n            ctx.fillRect(i*width, j*height, width, height)\n        }\n    }\n}\n')),(0,r.kt)("h2",{id:"all-together"},"All together"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'export const SampleSensorData =\n    {\n    "data": [\n        {\n            "time": "2021-06-22 22:35:10.655000+00:00",\n            "detections_local": [\n                [\n                    0,\n                    0\n                ]\n            ],\n        "device_id": "00-17-0d-00-00-70-54-8a",\n        "room_tag": "office"\n        },\n        {\n            "time": "2021-06-22 22:35:10.655000+00:00",\n            "detections_local": [\n                [\n                    0.2,\n                    0.5\n                ]\n            ],\n        "device_id": "00-17-0d-00-00-70-54-8a",\n        "room_tag": "office"\n        },\n        {\n            "time": "2021-06-22 22:35:10.655000+00:00",\n            "detections_local": [\n                [\n                    0.2,\n                    0.1\n                ]\n            ],\n        "device_id": "00-17-0d-00-00-70-54-8a",\n        "room_tag": "office"\n        },\n                {\n            "time": "2021-06-22 22:35:10.655000+00:00",\n            "detections_local": [\n                [\n                    0.5,\n                    0.3\n                ],\n                                [\n                    0.1,\n                    0.9\n                ], \n                [\n                    0.2,\n                    0.5\n                ]\n            ],\n        "device_id": "00-17-0d-00-00-70-54-8a",\n        "room_tag": "office"\n        },\n    ]\n}\n\nexport function rotate(cx, cy, x, y, degrees) {\n    var radians = degres * Math.PI/180,,\n        cos = Math.cos(radians),\n        sin = Math.sin(radians),\n        nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,\n        ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;\n    return [nx, ny];\n}\n\nexport const Canvas = props => {\n  const canvasRef = useRef(null)\n  let grid = [[0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0]]\n  const draw = (ctx, grid, max_int) => {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n    ctx.fillStyle = \'#000000\'\n    ctx.beginPath()\n    const height = ctx.canvas.height/grid.length\n    const width = ctx.canvas.width/grid.length\n    ctx.globalAlpha = 0.01;\n    ctx.fillStyle = "red";\n    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n    for (var i = 0; i < grid.length; i++) { \n        for (var j = 0; j < grid[i].length; j++) { \n            ctx.beginPath()\n            ctx.globalAlpha = 0.95 * (grid[i][j])/max_int;\n            ctx.fillStyle = "red";\n            ctx.fillRect(i*width, j*height, width, height)\n        }\n    }\n  }\n  const sensor = {height: 2.76, orientation: [0, 0, 0], coordinates: [2.5, 2.5]}\n  const fov = 1.0472 // rad := 60 degrees\n  const sensorSize =  Math.tan(fov/2)*sensor.height*2 // this gives us the sensor projected coverage in meters\n  let sensorCenter = {X: sensorSize/2, Y: sensorSize/2}\n  useEffect(() => {\n    const canvas = canvasRef.current\n    const context = canvas.getContext(\'2d\')\n    let frameMax = SampleSensorData.data.length\n    let gridSize = {width: 5, height: 5} // meters\n    //Our draw came here\n    let maxInt = 0\n    const render = () => {\n        for (var i = 0; i < SampleSensorData.data.length; i++) {\n            SampleSensorData.data[i].detections_local.forEach(function(item, index) {\n                // Scale the detection to the sensor size, [0,0] is top left [x,y]\n                const xLocal = item[0] * sensorSize\n                const yLocal = item[1] * sensorSize\n                // Then rotate the detection to the local frame, orientation is in terms of the center, so we need to rotate around the center\n                // Note we only rotate around the z axis (roll)\n                const rotated = rotate(sensorCenter.X, sensorCenter.Y, xLocal, yLocal, sensor.orientation[2])\n                // Next we translate to the global frame, note coordinates are to the sensor center, so we need to subtract the sensor center\n                const xGlobal = rotated[0] + sensor.coordinates[0] - sensorCenter.X\n                const yGlobal = rotated[1] + sensor.coordinates[1] - sensorCenter.Y\n                // Now we place this into the grid, we need to convert the meters to the grid size\n                const xGrid = Math.floor((xGlobal/gridSize.width) * grid.length)\n                const yGrid = Math.floor((yGlobal/gridSize.height) * grid.length)\n                grid[xGrid][yGrid] += 1\n                if (grid[xGrid][yGrid] > maxInt) {\n                    maxInt = grid[xGrid][yGrid]\n                }\n            })\n        }\n        draw(context, grid, maxInt)\n    }\n    render()\n  }, [draw])\n  return <canvas ref={canvasRef} {...props}/>\n}\n')))}u.isMDXComponent=!0}}]);